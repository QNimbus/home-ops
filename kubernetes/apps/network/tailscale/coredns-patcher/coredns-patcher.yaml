---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: coredns-patcher
  namespace: network
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: coredns-patcher
rules:
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get", "patch"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "patch"]
- apiGroups: ["tailscale.com"]
  resources: ["dnsconfigs"]
  verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: coredns-patcher
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: coredns-patcher
subjects:
- kind: ServiceAccount
  name: coredns-patcher
  namespace: network
---
apiVersion: batch/v1
kind: Job
metadata:
  name: coredns-tailscale-patcher
  namespace: network
  annotations:
    kustomize.toolkit.fluxcd.io/substitute: "disabled"
spec:
  ttlSecondsAfterFinished: 60
  template:
    spec:
      serviceAccountName: coredns-patcher
      restartPolicy: OnFailure
      containers:
      - name: patcher
        image: bitnami/kubectl:latest
        command:
        - /bin/bash
        - -c
        - |
          set -e
          echo "Starting CoreDNS Tailscale DNS configuration..."

          # Wait for the DNSConfig to have a nameserver IP
          timeout=300
          while [ $timeout -gt 0 ]; do
            TAILSCALE_DNS_IP=$(kubectl get dnsconfig tailscale-dns -n network -o jsonpath='{.status.nameserver.ip}' 2>/dev/null || echo "")
            if [ -n "$TAILSCALE_DNS_IP" ] && [ "$TAILSCALE_DNS_IP" != "null" ]; then
              echo "Found Tailscale DNS server at: $TAILSCALE_DNS_IP"
              break
            fi
            echo "Waiting for DNSConfig to be ready... (${timeout}s remaining)"
            sleep 10
            timeout=$((timeout - 10))
          done

          if [ -z "$TAILSCALE_DNS_IP" ] || [ "$TAILSCALE_DNS_IP" = "null" ]; then
            echo "ERROR: Could not get Tailscale DNS IP after waiting"
            exit 1
          fi

          # Get the current CoreDNS Corefile
          kubectl get configmap coredns -n kube-system -o jsonpath='{.data.Corefile}' > /tmp/current-corefile

          # Check if ts.net section already exists and get its current IP
          CURRENT_TS_IP=""
          if grep -q "ts\.net" /tmp/current-corefile; then
            CURRENT_TS_IP=$(grep -A3 "ts\.net" /tmp/current-corefile | grep "forward \." | awk '{print $3}')
            echo "Found existing ts.net section with IP: $CURRENT_TS_IP"

            # If the IP hasn't changed, skip the update
            if [ "$CURRENT_TS_IP" = "$TAILSCALE_DNS_IP" ]; then
              echo "Tailscale DNS IP hasn't changed ($TAILSCALE_DNS_IP). No update needed."
              exit 0
            fi

            echo "Tailscale DNS IP changed from $CURRENT_TS_IP to $TAILSCALE_DNS_IP. Updating..."
            # Remove the entire ts.net block
            sed -i '/ts\.net/,/^    }/d' /tmp/current-corefile
          else
            echo "No existing ts.net section found. Adding new configuration..."
          fi

          # Add the ts.net section
          cat >> /tmp/current-corefile << EOF
          ts.net {
              errors
              cache 30
              forward . $TAILSCALE_DNS_IP
          }
          EOF

          # Escape the Corefile for JSON
          ESCAPED_COREFILE=$(cat /tmp/current-corefile | jq -Rs .)

          # Patch the CoreDNS ConfigMap
          kubectl patch configmap coredns -n kube-system --type merge -p "{\"data\":{\"Corefile\":$ESCAPED_COREFILE}}"

          echo "CoreDNS configured successfully with Tailscale DNS at $TAILSCALE_DNS_IP"

          # Restart CoreDNS pods to pick up the new configuration
          kubectl rollout restart deployment coredns -n kube-system
          echo "CoreDNS deployment restarted"
